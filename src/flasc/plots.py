# Plotting objects for FLASC
# Author: Leland McInnes <leland.mcinnes@gmail.com>
# Adapted for FLASC by Jelmer Bot
# License: BSD 3 clause
import numpy as np
from warnings import warn
from hdbscan.plots import _get_leaves

CB_LEFT = 0
CB_RIGHT = 1
CB_BOTTOM = 2
CB_TOP = 3


class _BaseCondensedTree:
    """Class with conversion functions shared between both types of condensed
    tree.

    Parameters
    ----------
    raw_tree : numpy recarray from :class:`~hdbscan.HDBSCAN`
        The raw numpy rec array version of the condensed tree as produced
        internally by hdbscan.
    """

    def __init__(self, raw_tree, labels):
        self._raw_tree = raw_tree
        self._labels = labels

    def _select_clusters(self):
        """Recovers selected clusters respecting selection parameters."""
        selected_clusters = dict()
        for row in self._raw_tree:
            if row["child_size"] > 1:
                continue
            label = self._labels[row["child"]]
            if label >= 0:
                selected_clusters[label] = min(
                    selected_clusters.get(label, np.inf), row["parent"]
                )

        return sorted(selected_clusters.values())

    def get_plot_data(
        self,
        log_size=False,
        leaf_separation=1,
        max_rectangle_per_icicle=20,
        labels=None,
    ):
        """
        Generates data for use in plotting the 'icicle plot' or dendrogram
        plot of a branch condensed tree generated by HDBSCAN.

        Parameters
        ----------
        labels : numpy array
            The subgroup-label of each point.

        log_size : boolean, optional
            Use log scale for the 'size' of clusters (i.e. number of
            points in the cluster at a given lambda value). (default
            False)

        leaf_separation : float, optional
            How far apart to space the final leaves of the
            dendrogram. (default 1)

        max_rectangles_per_icicle : int, optional
            To simplify the plot this method will only emit
            ``max_rectangles_per_icicle`` bars per branch of the dendrogram.
            This ensures that we don't suffer from massive overplotting in
            cases with a lot of data points.

        override_labels : str
            Override with different labels.

        Returns
        -------
        plot_data : dict
            Data associated to bars in a bar plot:
                `bar_centers` x coordinate centers for bars
                `bar_tops` heights of bars in lambda scale
                `bar_bottoms` y coordinate of bottoms of bars
                `bar_widths` widths of the bars (in x coord scale)
                `bar_labels` data point label for each bar
                `cluster_bounds` a 4-tuple of [left, right, bottom, top] giving
                the bounds on a full set of cluster bars
            Data associates with cluster splits:
                `line_xs` x coordinates for horizontal dendrogram lines
                `line_ys` y coordinates for horizontal dendrogram lines
        label_start : int
            The minimum label value (excluding noise labels).
        label_end : int
            The maximum label value (excluding noise labels).
        """
        leaves = _get_leaves(self._raw_tree)
        last_leaf = self._raw_tree["parent"].max()
        root = self._raw_tree["parent"].min()
        if labels is None:
            labels = self._labels

        # We want to get the x and y coordinates for the start of each cluster
        # Initialize the leaves, since we know where they go, the iterate
        # through everything from the leaves back, setting coords as we go
        if isinstance(leaves, np.int64):
            cluster_x_coords = {leaves: leaf_separation}
        else:
            cluster_x_coords = dict(
                zip(leaves, [leaf_separation * x for x in range(len(leaves))])
            )
        cluster_y_coords = {root: 0.0}

        # print(last_leaf, root)
        for cluster in range(last_leaf, root - 1, -1):
            split = self._raw_tree[["child", "lambda_val"]]
            split = split[
                (self._raw_tree["parent"] == cluster)
                & (self._raw_tree["child_size"] > 1)
            ]
            # print(cluster, len(split))
            if len(split["child"]) > 1:
                left_child, right_child = split["child"]
                cluster_x_coords[cluster] = np.mean(
                    [
                        cluster_x_coords[left_child],
                        cluster_x_coords[right_child],
                    ]
                )
                cluster_y_coords[left_child] = split["lambda_val"][0]
                cluster_y_coords[right_child] = split["lambda_val"][1]

        # We use bars to plot the 'icicles', so we need to generate centers, tops,
        # bottoms and widths for each rectangle. We can go through each cluster
        # and do this for each in turn.
        bar_centers = []
        bar_tops = []
        bar_bottoms = []
        bar_widths = []
        bar_labels = []

        cluster_bounds = {}

        scaling = np.sum(self._raw_tree[self._raw_tree["parent"] == root]["child_size"])

        if log_size:
            scaling = np.log(scaling)

        for c in range(last_leaf, root - 1, -1):
            cluster_bounds[c] = [0, 0, 0, 0]

            c_children = self._raw_tree[self._raw_tree["parent"] == c]
            point_children = c_children["child"][c_children["child"] < root]
            if len(point_children) == 0:
                label = 0
            else:
                label = labels[point_children].min()
            current_size = np.sum(c_children["child_size"])
            current_lambda = cluster_y_coords[c]
            cluster_max_size = current_size
            cluster_max_lambda = c_children["lambda_val"].max()
            cluster_min_size = np.sum(
                c_children[c_children["lambda_val"] == cluster_max_lambda]["child_size"]
            )

            if log_size:
                current_size = np.log(current_size)
                cluster_max_size = np.log(cluster_max_size)
                cluster_min_size = np.log(cluster_min_size)

            total_size_change = float(cluster_max_size - cluster_min_size)
            step_size_change = total_size_change / max_rectangle_per_icicle

            cluster_bounds[c][CB_LEFT] = cluster_x_coords[c] * scaling - (
                current_size / 2.0
            )
            cluster_bounds[c][CB_RIGHT] = cluster_x_coords[c] * scaling + (
                current_size / 2.0
            )
            cluster_bounds[c][CB_BOTTOM] = cluster_y_coords[c]
            cluster_bounds[c][CB_TOP] = np.max(c_children["lambda_val"])

            last_step_size = current_size
            last_step_lambda = current_lambda

            for i in np.argsort(c_children["lambda_val"]):
                row = c_children[i]
                if row["lambda_val"] != current_lambda and (
                    last_step_size - current_size > step_size_change
                    or row["lambda_val"] == cluster_max_lambda
                ):
                    bar_centers.append(cluster_x_coords[c] * scaling)
                    bar_tops.append(row["lambda_val"] - last_step_lambda)
                    bar_bottoms.append(last_step_lambda)
                    bar_widths.append(last_step_size)
                    bar_labels.append(label)
                    last_step_size = current_size
                    last_step_lambda = current_lambda
                if log_size:
                    exp_size = np.exp(current_size) - row["child_size"]
                    # Ensure we don't try to take log of zero
                    if exp_size > 0.01:
                        current_size = np.log(np.exp(current_size) - row["child_size"])
                    else:
                        current_size = 0.0
                else:
                    current_size -= row["child_size"]
                current_lambda = row["lambda_val"]

        # Finally we need the horizontal lines that occur at cluster splits.
        line_xs = []
        line_ys = []

        for row in self._raw_tree[self._raw_tree["child_size"] > 1]:
            parent = row["parent"]
            child = row["child"]
            child_size = row["child_size"]
            if log_size:
                child_size = np.log(child_size)
            sign = np.sign(cluster_x_coords[child] - cluster_x_coords[parent])
            line_xs.append(
                [
                    cluster_x_coords[parent] * scaling,
                    cluster_x_coords[child] * scaling + sign * (child_size / 2.0),
                ]
            )
            line_ys.append([cluster_y_coords[child], cluster_y_coords[child]])

        return (
            {
                "bar_centers": bar_centers,
                "bar_tops": bar_tops,
                "bar_bottoms": bar_bottoms,
                "bar_widths": bar_widths,
                "bar_labels": bar_labels,
                "line_xs": line_xs,
                "line_ys": line_ys,
                "cluster_bounds": cluster_bounds,
            },
            labels[labels >= 0].min(),
            labels.max(),
        )

    def _plot(
        self,
        plot_data,
        label_start,
        label_end,
        selection_palette=None,
        color_centre_as_noise=False,
        label_clusters=False,
        label_kws=None,
        label_offset_factor=0.7,
        axis=None,
    ):
        try:
            import matplotlib as mc
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError(
                "You must install the matplotlib library to plot the condensed tree."
                "Use get_plot_data to calculate the relevant data without plotting."
            )

        if selection_palette is None:
            selection_palette = mc.colormaps["tab10"].colors

        if color_centre_as_noise:
            bar_colors = [
                (
                    selection_palette[l % len(selection_palette)]
                    if l >= 0 and l < label_end
                    else "silver"
                )
                for l in plot_data["bar_labels"]
            ]
        else:
            bar_colors = [
                (selection_palette[l % len(selection_palette)] if l >= 0 else "silver")
                for l in plot_data["bar_labels"]
            ]

        if axis is None:
            axis = plt.gca()
        axis.bar(
            plot_data["bar_centers"],
            plot_data["bar_tops"],
            bottom=plot_data["bar_bottoms"],
            width=plot_data["bar_widths"],
            color=bar_colors,
            align="center",
            linewidth=0,
        )

        drawlines = []
        for xs, ys in zip(plot_data["line_xs"], plot_data["line_ys"]):
            drawlines.append(xs)
            drawlines.append(ys)
        axis.plot(*drawlines, color="black", linewidth=1)

        if label_clusters:
            chosen_clusters = self._select_clusters()

            # Extract the chosen cluster bounds. If enough duplicate data points exist in the
            # data the lambda value might be infinite. This breaks labeling and highlighting
            # the chosen clusters.
            cluster_bounds = np.array(
                [plot_data["cluster_bounds"][c] for c in chosen_clusters]
            )
            if not np.isfinite(cluster_bounds).all():
                warn(
                    "Infinite lambda values encountered in chosen clusters."
                    " This might be due to duplicates in the data."
                )

            # Extract the plot range of the y-axis and set default center and height values for ellipses.
            # Extremely dense clusters might result in near infinite lambda values. Setting max_height
            # based on the percentile should alleviate the impact on plotting.
            plot_range = np.hstack([plot_data["bar_tops"], plot_data["bar_bottoms"]])
            plot_range = plot_range[np.isfinite(plot_range)]
            mean_y_center = np.mean([np.max(plot_range), np.min(plot_range)])
            max_height = np.diff(np.percentile(plot_range, q=[10, 90]))

            for i, c in enumerate(chosen_clusters):
                c_bounds = plot_data["cluster_bounds"][c]
                height = c_bounds[CB_TOP] - c_bounds[CB_BOTTOM]
                center = (
                    np.mean([c_bounds[CB_LEFT], c_bounds[CB_RIGHT]]),
                    np.mean([c_bounds[CB_TOP], c_bounds[CB_BOTTOM]]),
                )

                # Set center and height to default values if necessary
                if not np.isfinite(center[1]):
                    center = (center[0], mean_y_center)
                if not np.isfinite(height):
                    height = max_height

                axis.annotate(
                    str(i + label_start),
                    xy=center,
                    xytext=(
                        center[0],
                        center[1] + label_offset_factor * height,
                    ),
                    horizontalalignment="center",
                    verticalalignment="top",
                    **(label_kws or {}),
                )

        axis.set_xticks([])
        for side in ("right", "top", "bottom"):
            axis.spines[side].set_visible(False)
        axis.invert_yaxis()
        return axis

    def to_numpy(self):
        """Return a numpy structured array representation of the condensed tree."""
        return self._raw_tree.copy()

    def to_pandas(self):
        """Return a pandas dataframe representation of the condensed tree.

        Each row of the dataframe corresponds to an edge in the tree.
        The columns of the dataframe are `parent`, `child`, `lambda_val`
        and `child_size`.

        The `parent` and `child` are the ids of the
        parent and child nodes in the tree. Node ids less than the number
        of points in the original dataset represent individual points, while
        ids greater than the number of points are clusters.

        The `lambda_val` value is the value (1/distance) at which the `child`
        node leaves the cluster.

        The `child_size` is the number of points in the `child` node.
        """
        try:
            from pandas import DataFrame
        except ImportError:
            raise ImportError(
                "You must have pandas installed to export pandas DataFrames"
            )

        result = DataFrame(self._raw_tree)
        return result

    def to_networkx(self):
        """Return a NetworkX DiGraph object representing the condensed tree.

        Edge weights in the graph are the lambda values at which child nodes
        'leave' the parent cluster.

        Nodes have a `size` attribute attached giving the number of points
        that are in the cluster (or 1 if it is a singleton point) at the
        point of cluster creation (fewer points may be in the cluster at
        larger lambda values).
        """
        try:
            from networkx import DiGraph, set_node_attributes
        except ImportError:
            raise ImportError(
                "You must have networkx installed to export networkx graphs"
            )

        result = DiGraph()
        for row in self._raw_tree:
            result.add_edge(row["parent"], row["child"], weight=row["lambda_val"])

        set_node_attributes(
            result, dict(self._raw_tree[["child", "child_size"]]), "size"
        )

        return result


class BranchCondensedTree(_BaseCondensedTree):
    """The branch condensed tree structure, which provides a simplified or
    smoothed version of the :class:`~hdbscan.plots.SingleLinkageTree`.

    Parameters
    ----------
    condensed_tree_array : numpy recarray from :class:`~hdbscan.HDBSCAN`
        The raw numpy rec array version of the condensed tree as produced
        internally by hdbscan.

    labels : numpy array
        The final labels for each point in the dataset.

    cluster_points : numpy array
        An array listing point indices of the cluster this tree is for. Used to
        map from within-cluster indices to dataset indices.

    branch_selection_method : string, optional (default 'eom')
        The method of selecting clusters. One of 'eom' or 'leaf'

    allow_single_branch : Boolean, optional (default False)
        Whether to allow the root branch as the only selected branch
    """

    def __init__(
        self,
        tree,
        points,
        labels,
        branch_labels,
        cluster_labels,
    ):
        tree_labels = labels[points]
        super().__init__(tree, tree_labels)
        self.num_points = labels.shape[0]
        self.labels = labels
        self.branch_labels = branch_labels
        self.cluster_labels = cluster_labels
        self.points = points

    def plot(
        self,
        log_size=False,
        leaf_separation=1,
        max_rectangles_per_icicle=20,
        color_for="final",
        selection_palette=None,
        color_centre_as_noise=False,
        label_clusters=False,
        label_kws=None,
        label_offset_factor=0.7,
        axis=None,
    ):
        """Use matplotlib to plot an 'icicle plot' dendrogram of the condensed tree.

        Effectively this is a dendrogram where the width of each cluster bar is
        equal to the number of points (or log of the number of points) in the cluster
        at the given lambda value. Thus bars narrow as points progressively drop
        out of clusters. Bars are coloured and labelled by the selected branches.

        Parameters
        ----------
        log_size : boolean, optional (default False)
            Use log scale for the 'size' of clusters (i.e. number of points in
            the cluster at a given lambda value).

        leaf_separation : float, optional (default 1)
            How far apart to space the final leaves of the dendrogram.

        max_rectangles_per_icicle : int, optional (default 20)
            To simplify the plot this method will only emit
            ``max_rectangles_per_icicle`` bars per branch of the dendrogram.
            This ensures that we don't suffer from massive overplotting in cases
            with a lot of data points.

        color_for : str
            Specify which labels to color with: 'final', 'branch', 'cluster'.

        selection_palette : list of colors, optional (default None)
            If not None, and at least as long as the number of clusters, draw
            ovals in colors iterating through this palette. This can aid in
            cluster identification when plotting.

        color_centre_as_noise : boolean, optional (default False)
            If True, central points are coloured as noise points in the
            cluster condensed tree.

        label_clusters : boolean, optional (default True)
            If select_clusters is True then this determines whether to draw text
            labels on the clusters.

        label_kws : dict, optional (default None)
            Additional keyword arguments passed to `matplotlib.axes.Axes.annotate`

        label_offset_factor : float, optional (default 0.7)
            Controls height-wise offset of cluster labels.

        axis : matplotlib axis or None, optional (default None)
            The matplotlib axis to render to. If None then a new axis will be
            generated. The rendered axis will be returned.

        Returns
        -------
        axis : matplotlib axis
            The axis on which the 'icicle plot' has been rendered.
        """
        if color_for == "branch":
            override_labels = self.branch_labels[self.points]
        elif color_for == "cluster":
            override_labels = self.cluster_labels[self.points]
        else:
            override_labels = self.labels[self.points]
        plot_data, label_start, label_end = self.get_plot_data(
            log_size=log_size,
            leaf_separation=leaf_separation,
            max_rectangle_per_icicle=max_rectangles_per_icicle,
            labels=override_labels,
        )
        axis = self._plot(
            plot_data,
            label_start,
            label_end,
            selection_palette=selection_palette,
            color_centre_as_noise=color_centre_as_noise,
            label_clusters=label_clusters,
            label_kws=label_kws,
            label_offset_factor=label_offset_factor,
            axis=axis,
        )
        axis.set_ylabel("$e$ value")
        return axis


class ClusterCondensedTree(_BaseCondensedTree):
    """The cluster condensed tree structure, which provides a simplified or
    smoothed version of the :class:`~hdbscan.plots.SingleLinkageTree`.

    Parameters
    ----------
    condensed_tree_array : numpy recarray from :class:`~hdbscan.HDBSCAN`
        The raw numpy rec array version of the condensed tree as produced
        internally by hdbscan.

    cluster_labels : numpy array
        The cluster labels for each point in the dataset.

    cluster_selection_method : string, optional (default 'eom')
        The method of selecting clusters. One of 'eom' or 'leaf'

    cluster_selection_epsilon : float, optional (default 0)
        The applied epsilon value for selecting clusters.

    allow_single_cluster : Boolean, optional (default False)
        Whether to allow the root cluster as the only selected cluster
    """

    def __init__(self, condensed_tree_array, cluster_labels):
        super().__init__(condensed_tree_array, cluster_labels)

    def plot(
        self,
        log_size=False,
        leaf_separation=1,
        max_rectangles_per_icicle=20,
        selection_palette=None,
        label_clusters=False,
        label_kws=None,
        label_offset_factor=0.7,
        axis=None,
    ):
        """Use matplotlib to plot an 'icicle plot' dendrogram of the condensed tree.

        Effectively this is a dendrogram where the width of each cluster bar is
        equal to the number of points (or log of the number of points) in the cluster
        at the given lambda value. Thus bars narrow as points progressively drop
        out of clusters. Bars are colored and labelled by the selected clusters.

        Parameters
        ----------
        log_size : boolean, optional (default False)
            Use log scale for the 'size' of clusters (i.e. number of points in
            the cluster at a given lambda value).

        leaf_separation : float, optional (default 1)
            How far apart to space the final leaves of the dendrogram.

        max_rectangles_per_icicle : int, optional (default 20)
            To simplify the plot this method will only emit
            ``max_rectangles_per_icicle`` bars per branch of the dendrogram.
            This ensures that we don't suffer from massive overplotting in cases
            with a lot of data points.

        selection_palette : list of colors, optional (default None)
            If not None, and at least as long as the number of clusters, draw
            ovals in colors iterating through this palette. This can aid in
            cluster identification when plotting.

        label_clusters : boolean, optional (default True)
            If select_clusters is True then this determines whether to draw text
            labels on the clusters.

        label_kws : dict, optional (default None)
            Additional keyword arguments passed to `matplotlib.axes.Axes.annotate`

        label_offset_factor : float, optional (default 0.7)
            Controls height-wise offset of cluster labels.

        axis : matplotlib axis or None, optional (default None)
            The matplotlib axis to render to. If None then a new axis will be
            generated. The rendered axis will be returned.

        Returns
        -------
        axis : matplotlib axis
            The axis on which the 'icicle plot' has been rendered.
        """
        plot_data, label_start, label_end = self.get_plot_data(
            log_size=log_size,
            leaf_separation=leaf_separation,
            max_rectangle_per_icicle=max_rectangles_per_icicle,
        )
        axis = self._plot(
            plot_data,
            label_start,
            label_end,
            selection_palette=selection_palette,
            label_clusters=label_clusters,
            label_kws=label_kws,
            label_offset_factor=label_offset_factor,
            axis=axis,
        )
        axis.set_ylabel("$\\lambda$ value")
        return axis
